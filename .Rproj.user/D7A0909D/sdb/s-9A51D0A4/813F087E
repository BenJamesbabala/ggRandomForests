{
    "contents" : "####**********************************************************************\n####**********************************************************************\n####\n####  RANDOM FORESTS FOR SURVIVAL, REGRESSION, AND CLASSIFICATION (RF-SRC)\n####  Version 1.0.2\n####\n####  Copyright 2012, University of Miami\n####\n####  This program is free software; you can redistribute it and/or\n####  modify it under the terms of the GNU General Public License\n####  as published by the Free Software Foundation; either version 2\n####  of the License, or (at your option) any later version.\n####\n####  This program is distributed in the hope that it will be useful,\n####  but WITHOUT ANY WARRANTY; without even the implied warranty of\n####  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n####  GNU General Public License for more details.\n####\n####  You should have received a copy of the GNU General Public\n####  License along with this program; if not, write to the Free\n####  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n####  Boston, MA  02110-1301, USA.\n####\n####  ----------------------------------------------------------------\n####  Project Partially Funded By: \n####  ----------------------------------------------------------------\n####  Dr. Ishwaran's work was funded in part by DMS grant 1148991 from the\n####  National Science Foundation and grant R01 CA163739 from the National\n####  Cancer Institute.\n####\n####  Dr. Kogalur's work was funded in part by grant R01 CA163739 from the \n####  National Cancer Institute.\n####  ----------------------------------------------------------------\n####  Written by:\n####  ----------------------------------------------------------------\n####    Hemant Ishwaran, Ph.D.\n####    Director of Statistical Methodology\n####    Professor, Division of Biostatistics\n####    Clinical Research Building, Room 1058\n####    1120 NW 14th Street\n####    University of Miami, Miami FL 33136\n####\n####    email:  hemant.ishwaran@gmail.com\n####    URL:    http://web.ccs.miami.edu/~hishwaran\n####    --------------------------------------------------------------\n####    Udaya B. Kogalur, Ph.D.\n####    Adjunct Staff\n####    Dept of Quantitative Health Sciences\n####    Cleveland Clinic Foundation\n####    \n####    Kogalur & Company, Inc.\n####    5425 Nestleway Drive, Suite L1\n####    Clemmons, NC 27012\n####\n####    email:  kogalurshear@gmail.com\n####    URL:    http://www.kogalur.com\n####    --------------------------------------------------------------\n####\n####**********************************************************************\n####**********************************************************************\n\n\nplot.survival.rfsrc <- function (x,\n                          plots.one.page = TRUE,\n                          plot.it = TRUE,\n                          subset, collapse = FALSE,\n                          haz.model = c(\"spline\", \"ggamma\", \"nonpar\"),\n                          k = 25,\n                          span = \"cv\",\n                          cens.model = c(\"km\", \"rfsrc\"),\n                          ...)\n{\n\n  ## Incoming parameter checks.  All are fatal.\n  if (is.null(x)) {\n    stop(\"object x is empty!\")\n  }\n  if (sum(inherits(x, c(\"rfsrc\", \"grow\"), TRUE) == c(1, 2)) != 2 &\n      sum(inherits(x, c(\"rfsrc\", \"predict\"), TRUE) == c(1, 2)) != 2) {\n    stop(\"This function only works for objects of class `(rfsrc, grow)' or '(rfsrc, predict)'.\")\n  }\n  if (x$family != \"surv\") {\n    stop(\"this function only supports right-censored survival settings\")\n  }\n\n  ## predict object does not contain OOB values\n  if (sum(inherits(x, c(\"rfsrc\", \"predict\"), TRUE) == c(1, 2)) == 2) {\n    rfsrcPred <- TRUE\n  }\n  else {\n    rfsrcPred <- FALSE\n  }\n\n  ## grow objects under non-standard bootstrapping are OOB devoid\n  ## treat the object as if it were predict\n  if (is.null(x$predicted.oob)) {\n    rfsrcPred <- TRUE\n  }\n    \n  ## verify the haz.model option\n  haz.model <- match.arg(haz.model, c(\"spline\", \"ggamma\", \"nonpar\"))\n  ##ensure that the glmnet package is available when splines are selected\n  if (!missing(subset) && haz.model == \"spline\") {\n    if (!available(glmnet)) {#loads the package, otherwise sets haz.model to \"ggamma\"\n      warning(\"the 'glmnet' package is required for this option: reverting to 'ggamma' method instead\")\n      haz.model <- \"ggamma\"\n    }\n  }\n  \n  ## verify the cens.model option\n  cens.model <- match.arg(cens.model, c(\"km\", \"rfsrc\"))\n\n  ## use imputed missing time or censoring indicators\n  if (!is.null(x$yvar) && !is.null(x$imputed.indv)) {\n    x$yvar[x$imputed.indv, ]=x$imputed.data[, 1:2]\n  }\n\n  ## get the event data\n  event.info <- get.event.info(x)\n    \n  ## Process the subsetted index\n  ## Assumes the entire data set is to be used if not specified\n  if (missing(subset)) {\n    subset <- 1:x$n\n    subsetProvided <- FALSE\n  }\n  else {\n    ## convert the user specified subset into a usable form \n    if (is.logical(subset)) subset <- which(subset)\n    subset <- unique(subset[subset >= 1 & subset <= x$n])\n    plot.it <- subsetProvided <- TRUE\n    if (length(subset) == 0) {\n      stop(\"'subset' not set properly.\")\n    }\n  }\n\n  ## no point in producing plots if sample size is too small\n  if (!rfsrcPred && !subsetProvided && (x$n < 2 | x$ndead < 1)) {\n    stop(\"sample size or number of deaths is too small for meaningful analysis\")\n  }\n  \n  ## use OOB values for grow forest\n  if (rfsrcPred) {\n    mort    <- x$predicted[subset]\n    surv.ensb  <- t(x$survival[subset,, drop = FALSE])\n    chf.ensb <- x$chf[subset,, drop = FALSE]\n    y.lab   <- \"Mortality\"\n    title.1 <- \"Survival\"\n    title.2 <- \"Cumulative Hazard\"\n    title.3 <- \"Hazard\"\n    title.4 <- \"Mortality vs Time\"\n  }\n  else {\n    mort    <- x$predicted.oob[subset]\n    surv.ensb    <- t(x$survival.oob[subset,, drop = FALSE])\n    chf.ensb <- x$chf.oob[subset,, drop = FALSE]\n    y.lab   <- \"OOB Mortality\"\n    title.1 <- \"OOB Survival\"\n    title.2 <- \"OOB Cumulative Hazard\"\n    title.3 <- \"OOB Hazard\"\n    title.4 <- \"OOB Mortality vs Time\"\n  }\n\n   \n  ## mean ensemble survival\n  if (!subsetProvided) {\n    surv.mean.ensb <- apply(surv.ensb, 1, mean, na.rm = TRUE)\n  }\n\n  ## collapse across the subset?\n  if (subsetProvided && collapse) {\n    surv.ensb <- apply(surv.ensb, 1, mean, na.rm = TRUE)\n    chf.ensb <- rbind(apply(chf.ensb, 2, mean, na.rm = TRUE))\n  }\n\n\n  ##-------------------survival calculations------------------------\n  if (!rfsrcPred && !subsetProvided) {\n      \n    ## KM estimator\n    km.obj <- matrix(unlist(mclapply(1:length(event.info$time.interest),\n          function(j) {\n           c(sum(event.info$time >= event.info$time.interest[j], na.rm = TRUE),\n           sum(event.info$time[event.info$cens != 0] == event.info$time.interest[j], na.rm = TRUE))\n           })), ncol = 2, byrow = TRUE)\n    Y <- km.obj[, 1]\n    d <- km.obj[, 2]\n    r <- d / (Y + 1 * (Y == 0))\n    surv.aalen <- exp(-cumsum(r))\n\n    ## Estimate the censoring distribution    \n    sIndex <- function(x,y) {sapply(1:length(y), function(j) {sum(x <= y[j])})}\n    censTime <- sort(unique(event.info$time[event.info$cens == 0]))\n    censTime.pt <- c(sIndex(censTime, event.info$time.interest))\n\n    ## check to see if there are censoring cases\n    if (length(censTime) > 0) {\n      \n      ## KM estimator for the censoring distribution\n      if (cens.model == \"km\") {\n        censModel.obj <- matrix(unlist(mclapply(1:length(censTime),\n              function(j) {\n                c(sum(event.info$time >= censTime[j], na.rm = TRUE),\n                  sum(event.info$time[event.info$cens == 0] == censTime[j], na.rm = TRUE))\n              })), ncol = 2, byrow = TRUE)\n        Y <- censModel.obj[, 1]\n        d <- censModel.obj[, 2]\n        r <- d / (Y + 1 * (Y == 0))\n        cens.dist <- c(1, exp(-cumsum(r)))[1 + censTime.pt]\n      }\n        \n      # RFSRC estimator for the censoring distribution\n      else {\n        newd <- cbind(x$yvar, x$xvar)\n        newd[, 2] <- 1 * (newd[, 2] == 0)\n        cens.dist <- t(predict(x, newd, outcome = \"test\")$survival.oob)\n      }\n    }\n\n    ## no censoring cases; assign a default distribution\n    else {\n      cens.dist <- rep(1, length(censTime.pt))\n    }\n\n\n    ##-------------------brier calculations------------------------\n    ## Brier object\n    brier.obj <- matrix(unlist(mclapply(1:x$n, function(i)\n      {\n        tau <-  event.info$time\n        event <- event.info$cens\n        t.unq <- event.info$time.interest\n        cens.pt <- sIndex(t.unq, tau[i])\n        if (cens.model == \"km\") {\n          c1 <- 1 * (tau[i] <= t.unq & event[i] != 0)/c(1, cens.dist)[1 + cens.pt]\n          c2 <- 1 * (tau[i] > t.unq)/cens.dist\n        }\n        else {\n          c1 <- 1 * (tau[i] <= t.unq & event[i] != 0)/c(1, cens.dist[, i])[1 + cens.pt]\n          c2 <- 1 * (tau[i] > t.unq)/cens.dist[, i]\n        } \n        (1 * (tau[i] > t.unq) - surv.ensb[, i])^2 * (c1 + c2)\n      })), ncol = length(event.info$time.interest), byrow = TRUE)\n    \n    ## extract the Brier score stratified by mortality percentiles\n    brier.score <- matrix(NA, length(event.info$time.interest), 4)\n    mort.perc   <- c(min(mort, na.rm = TRUE) - 1e-5, quantile(mort, (1:4)/4, na.rm = TRUE))\n    for (k in 1:4){\n      mort.pt <- (mort > mort.perc[k]) & (mort <= mort.perc[k+1])\n      brier.score[, k] <- apply(brier.obj[mort.pt,, drop=FALSE], 2, mean, na.rm = TRUE)\n    }\n    brier.score <- as.data.frame(cbind(brier.score, apply(brier.obj, 2, mean, na.rm = TRUE)))\n    colnames(brier.score) <- c(\"q25\", \"q50\", \"q75\", \"q100\", \"all\") \n    \n  }\n  \n  ##-------------------hazard calculations------------------------\n  if (subsetProvided) {\n    ## we estimate the hazard function in three (3) different ways\n\n\n    ##survival function of generalized gamma\n    sggamma <- function(q, mu = 0, sigma = 1, Q)\n      {\n        sigma <- exp(sigma)#reparametrize sigma to be unconstrained\n        q[q < 0] <- 0\n        if (Q != 0) {\n          y <- log(q)\n          w <- (y - mu)/sigma\n          expnu <- exp(Q * w) * Q^-2\n          ret <- if (Q > 0) \n            pgamma(expnu, Q^-2)\n          else 1 - pgamma(expnu, Q^-2)\n        }\n        else {\n          ret <- plnorm(q, mu, sigma)\n        }\n        1 - ret\n      }\n    \n    ##density of generalized gamma\n    dggamma <- function(x, mu = 0, sigma = 1, Q) \n      {\n        sigma <- exp(sigma)#reparametrize sigma to be unconstrained\n        ret <- numeric(length(x))\n        ret[x <= 0] <- 0\n        xx <- x[x > 0]\n        if (Q != 0) {\n          y <- log(xx)\n          w <- (y - mu)/sigma\n          logdens <- -log(sigma * xx) + log(abs(Q)) + (Q^-2) * \n            log(Q^-2) + Q^-2 * (Q * w - exp(Q * w)) - lgamma(Q^-2)\n        }\n        else logdens <- dlnorm(xx, mu, sigma, log = TRUE)\n        ret[x > 0] <- exp(logdens)\n        ret\n      }\n\n    ##hazard of generalized gamma\n    hggamma <- function(x, mu = 0, sigma = 1, Q)\n      {\n        dggamma(x = x, mu = mu, sigma = sigma, Q = Q) / sggamma(q = x, \n                              mu = mu, sigma = sigma, Q = Q)\n      }\n    \n    haz.list <- mclapply(1:nrow(chf.ensb), function(i) { \n\n      ## method (1)\n      ## fit a 3-parameter generalized gamma model\n      ## basic functions have been shamelessly taken from library(flexsurv)\n\n      if (haz.model == \"ggamma\") {\n        ##extract time and S(t)\n        x <- event.info$time.interest\n        y <- t(surv.ensb)[i, ]\n        \n        ##smooth H(t)\n        ll <- supsmu(x, y, span = span)\n\n        ## the optimization function is the mean RSS between\n        ## the survival function and the generalized gamma\n        fn <- function(z) {\n          mean((y - sggamma(x, mu = z[1], sigma = z[2], Q = z[3]))^2, na.rm = TRUE)\n        }\n\n        ## initialize the parameters and optimize\n        init <- c(0, 1, 0)\n        optim.obj <- optim(init, fn)\n\n        ## extract the final parameters\n        if (optim.obj$convergence != 0) warning(\"fit.ggamma failed to converge\")\n        parm <- optim.obj$par\n\n        ## return the hazard\n        list(x = x, y = hggamma(x, parm[1], parm[2], parm[3]))\n      \n      }\n\n      ## method (2)\n      ## Royston and Parmar spline approach for log H(t)\n      ## log H(t) = s(x, gamma), where x = log(t)\n\n      else if (haz.model == \"spline\") {\n\n\n        ##extract the time variable\n        tm <- event.info$time.interest\n\n        ##shift time to the right to avoid numerical issues with log(0)\n        shift.time <- ifelse(min(tm, na.rm = TRUE) < 1e-3, 1e-3, 0)\n        ##shift.time <- 0\n\n        ##take the log of time: these are the x-values used in the glmnet call\n        log.tm <- log(tm + shift.time)\n        \n        ##translate the CHF by a constant to avoid numerical issues with log\n        shift.chf <- 1\n        \n        ##take the log of the CHF: this is the \"response\" in the glmnet call\n        y <- log(chf.ensb[i, ] + shift.chf)\n\n\n        ##define the knots\n        k <- max(k, 2)\n        knots <- unique(c(seq(min(log.tm), max(log.tm), length = k), 5 * max(log.tm)))\n\n        \n        ##define the spline basis functions\n        m <- length(knots) \n        kmin <- min(knots)\n        kmax <- max(knots)\n\n        if (m < 2) {\n          stop(\"not enough knots (confirm that the number of unique event times > 2\")\n        }\n        x <- do.call(cbind, mclapply(1:(m+1), function(j) {\n          if (j == 1) {\n            log.tm\n          }\n          else {\n            lj <- (kmax - knots[j-1]) / (kmax - kmin)\n            pmax(log.tm - knots[j-1], 0)^3 - lj * pmax(log.tm - kmin, 0)^3 - (1 - lj) * pmax(log.tm - kmax, 0)^3 \n          }\n        }))\n\n        ## lasso estimation\n        ## we use cross-validation with glmnet to estimate the gamma coefficients\n        ## from s(x, gamma)\n        cv.obj <- tryCatch({cv.glmnet(x, y, alpha = 1)}, error = function(ex){NULL})\n        if (!is.null(cv.obj)) {\n          coeff <- as.vector(predict(cv.obj, type = \"coef\", s = \"lambda.1se\"))\n        }\n        else {\n          warning(\"glmnet did not converge: setting coefficients to zero\")\n          coeff <- rep(0, 1+ ncol(x))\n        }\n\n        ## calculate s(x, gamma)\n        sfn <- coeff[1] + x %*% coeff[-1]\n\n        ## theoretical s'(x, gamma)\n        x.deriv <- do.call(cbind, mclapply(1:m, function(j) {\n          lj <- (kmax - knots[j]) / (kmax - kmin)\n          3 * (pmax(log.tm - knots[j], 0)^2 - lj * pmax(log.tm - kmin, 0)^2\n                            - (1 - lj) * pmax(log.tm - kmax, 0)^2)\n          \n        }))\n        sfn.deriv <- coeff[2] + x.deriv %*% coeff[-c(1:2)]\n\n       \n        ## take the derivative of H(t) to obtain the estimated hazard\n        ## this is (ds(x, gamma)/dt) * exp(s(x, gamma))\n        ## which equals s'(x, gamma) * (dx/dt) * exp(s(x, gamma))\n        ## x=log(t+shift.time), thus dx/dt = 1/(t + shift.time)\n        haz <- sfn.deriv * exp(sfn) / (tm + shift.time)\n\n        ## negative values are set to 0\n        ## smooth the hazard\n        ## negative values are set to 0\n        haz[haz < 0] <- 0\n        haz <- supsmu(tm, haz)$y\n        haz[haz < 0] <- 0\n\n        ##return the obj\n        #supsmu(tm, haz)\n        list(x = tm, y = haz)\n  \n      }\n\n      ## method (3)\n      ## nonparametric estimate\n      ## smooth the derivative of the smoothed H(t) \n\n      else if (haz.model == \"nonpar\") {\n\n        ##extract time and H(t)\n        x <- event.info$time.interest\n        y <- chf.ensb[i, ]\n\n        ##smooth H(t)\n        ll <- supsmu(x, y, span = \"cv\")\n        ##smooth the derivative of the smoothed H(t)\n        supsmu(x = ll$x[-length(x)], y = diff(ll$y) / diff(ll$x), span = span)\n        \n      }\n\n\n    })\n    \n  }\n    \n  \n  ## should we display the plots? \n  if (plot.it) {\n    \n    old.par <- par(no.readonly = TRUE)\n    if (plots.one.page) {\n      if (rfsrcPred && !subsetProvided) {\n        if (!is.null(x$yvar)) {#survival/mortality only\n          par(mfrow = c(1,2))\n        }\n        else {#predict mode but no outcomes: survival only\n          par(mfrow = c(1,1))\n        }\n      }\n      else {\n        par(mfrow = c(2,2))\n      }\n    }\n    else {#plots on one page\n      par(mfrow=c(1,1))\n    }\n    par(cex = 1.0)\n\n    ###----survival plot----\n    if (!subsetProvided && x$n > 500) {\n      r.pt <- sample(1:x$n, 500, replace = FALSE)\n      matplot(event.info$time.interest,\n              surv.ensb[, r.pt],\n              xlab = \"Time\",\n              ylab = title.1,\n              type = \"l\",\n              col = 1, \n              lty = 3, ...)\n    }\n    else {\n      matplot(event.info$time.interest,\n              surv.ensb,\n              xlab = \"Time\",\n              ylab = title.1,\n              type = \"l\",\n              col = 1,\n              lty = 3, ...)\n    }\n    if (!rfsrcPred && !subsetProvided) {\n      lines(event.info$time.interest, surv.aalen, lty = 1, col = 3, lwd = 3)\n    }\n    if (!subsetProvided) {\n      lines(event.info$time.interest, surv.mean.ensb, lty = 1, col = 2, lwd = 3)\n    }\n    rug(event.info$time.interest, ticksize=-0.03)\n    if (plots.one.page) {\n      title(title.1, cex.main = 1.25)\n    }\n\n    ###----CHF plot----\n    if (subsetProvided) {\n      matplot(event.info$time.interest,\n              t(chf.ensb),\n              xlab = \"Time\",\n              ylab = title.2,\n              type = \"l\",\n              col = 1,\n              lty = 3, ...)\n      matlines(haz.list[[1]]$x,\n               do.call(cbind, mclapply(haz.list, function(ll){cumsum(ll$y * c(0, diff(ll$x)))})),\n               type = \"l\",\n               col = 4,\n               lty = 3, ...)\n      rug(event.info$time.interest, ticksize=-0.03)\n      if (plots.one.page) {\n        title(title.2, cex.main = 1.25)\n      }\n    }\n\n    ###----hazard plot----\n    if (subsetProvided) {\n      plot(range(haz.list[[1]]$x, na.rm = TRUE),\n           range(unlist(mclapply(haz.list, function(ll) {ll$y})), na.rm = TRUE),\n           type = \"n\",\n           xlab = \"Time\",\n           ylab = title.3, ...)\n      void <- lapply(haz.list, function(ll) {\n        lines(ll, type = \"l\", col = 1, lty = 3)\n      })\n      rug(event.info$time.interest, ticksize=-0.03)\n      if (plots.one.page) {\n        title(title.3, cex.main = 1.25)\n      }\n    }\n    \n    ###----Brier plot----\n    if (!rfsrcPred && !subsetProvided) {\n      matplot(event.info$time.interest, brier.score,\n              xlab = \"Time\",\n              ylab = \"OOB Brier Score\",\n              type = \"l\",\n              lwd  = c(rep(1, 4), 2),\n              col  = c(rep(1, 4), 2),\n              lty  = c(1:4, 1), ...)\n      point.x=round(length(event.info$time.interest)*c(3,4)/4)\n      text(event.info$time.interest[point.x],brier.score[point.x,1],\"0-25\",col=4)\n      text(event.info$time.interest[point.x],brier.score[point.x,2],\"25-50\",col=4)\n      text(event.info$time.interest[point.x],brier.score[point.x,3],\"50-75\",col=4)\n      text(event.info$time.interest[point.x],brier.score[point.x,4],\"75-100\",col=4)\n      rug(event.info$time.interest,ticksize=0.03)\n      if (plots.one.page) title(\"OOB Brier Score\",cex.main = 1.25)\n    }\n\n    ###----mortality plot----\n    if (!subsetProvided && !is.null(x$yvar)) {\n      plot(event.info$time, mort, xlab = \"Time\", ylab = y.lab, type = \"n\", ...)\n      if (plots.one.page) {\n        title(title.4, cex.main = 1.25)\n      }\n      if (x$n > 500) cex <- 0.5 else cex <- 0.75\n      points(event.info$time[event.info$cens != 0], mort[event.info$cens != 0], pch = 16, col = 4, cex = cex)\n      points(event.info$time[event.info$cens == 0], mort[event.info$cens == 0], pch = 16, cex = cex)\n      if (sum(event.info$cens != 0) > 1)\n        lines(supsmu(event.info$time[event.info$cens != 0][order(event.info$time[event.info$cens != 0])],\n                     mort[event.info$cens != 0][order(event.info$time[event.info$cens != 0])]),\n              lty = 3,\n              col = 4,\n              cex = cex)\n      if (sum(event.info$cens == 0) > 1)\n        lines(supsmu(event.info$time[event.info$cens == 0][order(event.info$time[event.info$cens == 0])],\n                     mort[event.info$cens == 0][order(event.info$time[event.info$cens == 0])]),\n              lty = 3,\n              cex = cex)\n      rug(event.info$time.interest, ticksize=-0.03)\n    }\n\n    ## reset par\n    par(old.par)\n    \n  }\n\n  ##invisibly return the brier score\n  if (!rfsrcPred && !subsetProvided) {\n    \n    ##integrated Brier using the trapezoidal rule\n    Dint <- function(f, range, grid) {\n      a <-  range[1]\n      b <-  range[2]\n      f <- f[grid >= a & grid <= b]\n      grid <- grid[grid >= a & grid <= b]\n      m <- length(grid)\n      if ((b - a) <= 0 | m < 2) {\n        0\n      }\n      else {\n        (1 / ( 2 * diff(range)) ) * sum((f[2:m] + f[1:(m-1)])  * diff(grid))\n      }\n    }\n    \n    invisible(cbind(\n       time = event.info$time.interest,\n       brier.score,\n       integrate = unlist(mclapply(1:length(event.info$time.interest),\n         function(j) {\n           Dint(f = brier.score[1:j, 4],\n                range = quantile(event.info$time.interest, probs = c(0.05, 0.95), na.rm = TRUE),\n                grid = event.info$time.interest[1:j])\n         }))\n                    ))\n  }\n  \n}\n\n\nplot.survival <- plot.survival.rfsrc\n",
    "created" : 1357310119974.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3658733348",
    "id" : "813F087E",
    "lastKnownWriteTime" : 1357306809,
    "path" : "~/devel/ggrfsrc/R/ggplot.survival.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}